/*!
 * Lightweight JSZip-compatible subset for ContentShare.
 * Supports: new JSZip(), zip.file(name, data), zip.generateAsync({type:'blob'})
 */
(function (global) {
  'use strict';

  function crcTable() {
    const table = new Uint32Array(256);
    for (let n = 0; n < 256; n++) {
      let c = n;
      for (let k = 0; k < 8; k++) c = (c & 1) ? (0xedb88320 ^ (c >>> 1)) : (c >>> 1);
      table[n] = c >>> 0;
    }
    return table;
  }
  const CRC_TABLE = crcTable();

  function crc32(bytes) {
    let c = 0xffffffff;
    for (let i = 0; i < bytes.length; i++) c = CRC_TABLE[(c ^ bytes[i]) & 0xff] ^ (c >>> 8);
    return (c ^ 0xffffffff) >>> 0;
  }

  function encodeUtf8(str) {
    return new TextEncoder().encode(String(str || ''));
  }

  function writeU16(arr, v) {
    arr.push(v & 0xff, (v >>> 8) & 0xff);
  }

  function writeU32(arr, v) {
    arr.push(v & 0xff, (v >>> 8) & 0xff, (v >>> 16) & 0xff, (v >>> 24) & 0xff);
  }

  function dosDateTime(date) {
    const d = date instanceof Date ? date : new Date();
    const year = Math.max(1980, d.getFullYear());
    const dosTime = ((d.getHours() & 0x1f) << 11) | ((d.getMinutes() & 0x3f) << 5) | ((Math.floor(d.getSeconds() / 2)) & 0x1f);
    const dosDate = (((year - 1980) & 0x7f) << 9) | (((d.getMonth() + 1) & 0x0f) << 5) | (d.getDate() & 0x1f);
    return { dosTime, dosDate };
  }

  async function toUint8(data) {
    if (data instanceof Uint8Array) return data;
    if (data instanceof ArrayBuffer) return new Uint8Array(data);
    if (typeof Blob !== 'undefined' && data instanceof Blob) return new Uint8Array(await data.arrayBuffer());
    if (typeof data === 'string') return encodeUtf8(data);
    if (data == null) return new Uint8Array(0);
    throw new Error('Unsupported zip data type');
  }

  function JSZipLite() {
    this._files = [];
  }

  JSZipLite.prototype.file = function (name, data) {
    this._files.push({ name: String(name || 'file'), data: data });
    return this;
  };

  JSZipLite.prototype.generateAsync = async function (opts) {
    const type = (opts && opts.type) || 'blob';
    if (type !== 'blob') throw new Error('Only {type:"blob"} is supported');

    const localChunks = [];
    const centralChunks = [];
    let offset = 0;

    for (const item of this._files) {
      const nameBytes = encodeUtf8(item.name);
      const dataBytes = await toUint8(item.data);
      const crc = crc32(dataBytes);
      const size = dataBytes.length >>> 0;
      const dt = dosDateTime(new Date());

      const local = [];
      writeU32(local, 0x04034b50);
      writeU16(local, 20);
      writeU16(local, 0x0800);
      writeU16(local, 0);
      writeU16(local, dt.dosTime);
      writeU16(local, dt.dosDate);
      writeU32(local, crc);
      writeU32(local, size);
      writeU32(local, size);
      writeU16(local, nameBytes.length);
      writeU16(local, 0);
      localChunks.push(new Uint8Array(local), nameBytes, dataBytes);

      const central = [];
      writeU32(central, 0x02014b50);
      writeU16(central, 20);
      writeU16(central, 20);
      writeU16(central, 0x0800);
      writeU16(central, 0);
      writeU16(central, dt.dosTime);
      writeU16(central, dt.dosDate);
      writeU32(central, crc);
      writeU32(central, size);
      writeU32(central, size);
      writeU16(central, nameBytes.length);
      writeU16(central, 0);
      writeU16(central, 0);
      writeU16(central, 0);
      writeU16(central, 0);
      writeU32(central, 0);
      writeU32(central, offset);
      centralChunks.push(new Uint8Array(central), nameBytes);

      offset += local.length + nameBytes.length + dataBytes.length;
    }

    const centralSize = centralChunks.reduce((sum, chunk) => sum + chunk.length, 0);
    const eocd = [];
    writeU32(eocd, 0x06054b50);
    writeU16(eocd, 0);
    writeU16(eocd, 0);
    writeU16(eocd, this._files.length);
    writeU16(eocd, this._files.length);
    writeU32(eocd, centralSize);
    writeU32(eocd, offset);
    writeU16(eocd, 0);

    return new Blob([...localChunks, ...centralChunks, new Uint8Array(eocd)], { type: 'application/zip' });
  };

  global.JSZip = JSZipLite;
})(typeof self !== 'undefined' ? self : window);
